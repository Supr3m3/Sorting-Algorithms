<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
    <meta http-equiv="pragma" content="no-cache ">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Sorting Algorithms</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../vendor/bulma.min.css">
    <link rel="stylesheet" href="../../Code%20(CSS)/styles.css">
    <link href="../../Code (CSS)/startPages/allPages.css" rel="stylesheet" type="text/css"/>
    <script src="../../vendor/prism.js"></script>
    <link href="../../vendor/prism.css" rel="stylesheet" />
</head>
<body>
<selection>
    <div class="container is-fluid">
        <div class="columns">
            <div class="column All--Menu">
                    <a href="../start.html" class="button is-primary">Повернутися!</a>
                    <aside class="menu All--Menu__list">
                      <p class="menu-label">
                        <span class="tag is-black is-large">
                            Алгоритми сортування
                        </span>
                       </p>
                        <ul class="menu-list">
                          <div class="column All--list">
                              <!-- 1 -->
                              <li><a href="one.html" class="button is-white All--list__buttons">Bubble Sort</a></li>
                              <!-- 2 -->
                              <li><a href="two.html" class="button is-white All--list__buttons">Insertion Sort</a></li>
                              <!-- 3 -->
                              <li><a href="three.html" class="button is-white All--list__buttons">Quick Sort</a></li>
                              <!-- 4 -->
                              <li><a class="is-active All--list__buttons" id="All--list__activeButton" aria-current="page">Merge Sort</a></li>
                              <!-- 6 -->
                              <li><a href="six.html" class="button is-white All--list__buttons">Selection Sort</a></li>
                              <!-- 8 -->
                              <li><a href="eight.html" class="button is-white All--list__buttons">Bucket Sort</a></li>
                              <!-- 9 -->
                              <li><a href="nine.html" class="button is-white All--list__buttons">Shell Sort</a></li>
                              <!-- 10 -->
                              <li><a href="ten.html" class="button is-white All--list__buttons">Random Sort</a></li>
                            </div>
                          </ul>
                    </aside>
            </div>
            <div class="column is-8 All--Menu">
              <div class="columns">
                <div class="content">
                  <div class="column">
                    <div class="content">
                        <article class="message">
                            <div class="message-header">
                                <p>Сортування злиттям</p>
                                <button class="delete" aria-label="delete"></button>
                            </div>
                            <div class="message-body">
                                Сортування злиттям
                                У запропонованому Дж. фон Нейманом методі сортування злиттям, як і в методі Хоара, реалізовано принцип «розділяй та пануй». Масив ділиться навпіл, до кож­ної половини застосовується рекурсивно та сама процедура сортування злиттям, а відсортовані частини з'єднуються в один впорядкований масив.Отже, базовою операцією методу є злиття двох упорядкованих масивів в один. Ефективний спосіб виконання цієї операції полягає в тому, що елементи масивів порівнюються і за результатами порівняння в новий масив записується елемент або з першого, або з другого масиву. Один з масивів під час злиття може закін­читися раніше. В такому випадку елементи іншого масиву, які ще не були опра­цьовані, слід додати до нового масиву.
                                Час злиття упорядкованих масивів лінійно залежить від їх сумарної довжини. Враховуючи цей факт, неважко буде довести, що повне сортування методом злиття, як і сортування методом Хоара, потребує виконання 0(п log п) базових операцій над елементами масиву розмірності п.
                            </div>
                                </article>

                        <div class="column">
                          <pre class="line-numbers">
                            <code class="language-c">void Merge(int * a, int low, int high, int mid) {
  // We have low to mid and mid+1 to high already sorted.
  int i, j, k, temp[high - low + 1];
  i = low;
  k = 0;
  j = mid + 1;

  // Merge the two parts into temp[].
  while (i <= mid && j <= high) {
    if (a[i] < a[j]) {
      temp[k] = a[i];
      k++;
      i++;
    } else {
      temp[k] = a[j];
      k++;
      j++;
    }
  }

  // Insert all the remaining values from i to mid into temp[].
  while (i <= mid) {
    temp[k] = a[i];
    k++;
    i++;
  }

  // Insert all the remaining values from j to high into temp[].
  while (j <= high) {
    temp[k] = a[j];
    k++;
    j++;
  }

  // Assign sorted data stored in temp[] to a[].
  for (i = low; i <= high; i++) {
    a[i] = temp[i - low];
  }
}

// A function to split array into two parts.
void MergeSort(int * a, int low, int high) {
  int mid;
  if (low < high) {
    mid = (low + high) / 2;
    // Split the data into two half.
    MergeSort(a, low, mid);
    MergeSort(a, mid + 1, high);

    // Merge them to get sorted output.
    Merge(a, low, high, mid);
  }
}
                            </code>
                          </pre>

                            <pre class="line-numbers">
                            <code class="language-javascript">
                                function merge(left, right){
                                  var result = [],
                                      lLen = left.length,
                                      rLen = right.length,
                                      l = 0,
                                      r = 0;
                                  while(l < lLen && r < rLen){
                                     if(left[l] < right[r]){
                                       result.push(left[l++]);
                                     }
                                     else{
                                       result.push(right[r++]);
                                    }
                                  }
                                  //remaining part needs to be addred to the result
                                  return result.concat(left.slice(l)).concat(right.slice(r));
                                }

                            </code>
                          </pre>
                        </div>
                  </div>
              </div>
            </div>
        </div>
    </div>
</selection>
</body>
</html>